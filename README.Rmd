---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "tools/figs/README-",
  message = FALSE,
  warning = FALSE
)
```

# OpenSDP Data

A project to generate realistic synthetic unit-level longitudinal education data. 

## Design Goals

1. Generate synthetic education data that is realistic for use by analysts 
across the education sector. Realistic means messy, and reflective of the 
general pattern of relationships found in the U.S. education sector.
2. Synthetic data should be able to be generated on-demand and responsive to
inputs from the user. These inputs should allow the user to configure the
process to produce data that resembles the patterns of data in their agency.
3. The package should be modular and extendable allowing new data topics to be
generated as needed so synthetic data coverage can grow.

# Get Started

To use `OpenSDP.data`, follow the instructions below:

## Install Package

```{r eval=FALSE}
devtools::install_github("strategicdataproject/OpenSDP.data")
```

## Make some data

Ljoad the package

```{r, message=TRUE}
library(OpenSDP.data)
```



```{r, message=TRUE}
out <- simpop(nstu = 500, seed = 213, control = sim_control(nschls = 3))
head(out$demog_master %>% arrange(sid) %>% select(1:4))
head(out$stu_year, 10)
```

```{r, include=FALSE}
stu_year <- out$stu_year
demog_master <- out$demog_master
```


## Parameters

Default parameters can be modified by the user:

```{r demonstrateOptionList}
names(sim_control())
sim_control()$ell_list
```

These set some of the simulation requirements, but others are set using the 
`baseline` function family.

```{r}
get_baseline("ses")
```


### Diagnostics

How do we know it worked? We can look at the patterns of ELL enrollment that 
are observed and see what patterns are the most common. To do this, let's compute 
the frequency of transition states observed per student. 

```{r ellDiagnostic}
library(ggplot2)
library(tidyr)
plotdf <- stu_year %>% arrange(sid, year) %>% group_by(sid) %>% 
  do(tidy_sequence(.$ell, states = c(1, 0)))

plotdf$total <- rowSums(plotdf[, -1])
plotdf <- plotdf %>% gather(-sid, key = "Transition", value = "Count")

# plotdf %>% group_by(Transition) %>% filter(Transition != "total") %>%
#   summarize(sum(Count))

plotdf <- plotdf %>% filter(Transition != "total")  %>% 
  group_by(sid) %>% 
  mutate(total = sum(Count)) %>% 
  mutate(per = Count / total) %>% filter(Transition != "total")  %>% 
  separate(Transition, into = c("From", "To"), sep = "-") 

ggplot(plotdf, aes(Count)) + geom_histogram() + 
  scale_x_continuous(breaks = c(0:25)) + 
  facet_grid(From~To, labeller = label_both, switch = "y") + 
  theme_bw() + 
  labs(title = "Frequency of Transition States by Student - ELL", 
       y = "Count", x = "Times per Student State Observed")

```

Looking at this chart we can see that most students went from the No state to 
a No state -- as would be expected when there are few ELLs. 

Through this process we've gained students in the ELL status who were not 
initially ELL. Depending on our application this may not be desirable and we 
may want to modify the transition matrix to avoid this. Otherwise, later, 
this becomes an exercise in data cleaning. 

Two other visual diagnostics are below. 

```{r visualdiagnostics}
# Other plots

# ggplot(plotdf, aes(per)) + geom_density() + 
#   facet_grid(From ~ To, labeller = label_both, switch = "y") + 
#   theme_bw() + labs(title = "By Student Densities of Transitions")

# Heatmap
plotdf %>% group_by(From, To) %>% 
  summarise(Count = sum(Count)) %>% 
  ungroup %>% 
  mutate(total = sum(Count)) %>%
  mutate(per = Count/total) %>%
ggplot(aes(x = From, y = To, fill = per)) + 
  geom_tile(color= I("black")) + 
  geom_text(aes(label = round(per, digits = 2))) + 
  theme_minimal() +
  coord_cartesian() + labs(title = "Heatmap of ELL Transition States")

```


We can also do a comparative diagnostic. Given the relatively short length of 
our sequence per student, it will be hard to estimate fit from a short sequence. 


```{r testbyStudent}
# series <- stu_year$ell[stu_year$ID == "1705"]
# series <- stu_year$ell[stu_year$ID == "0001"]

test_fit <- function(series, expected){
  if(dim(table(series)) == 1){
    return(TRUE)
  } else {
  out <- fit_series(series, return = "fit", confidencelevel = 0.99, 
                    possibleStates = rownames(expected))
  low <- out$lowerEndpointMatrix < expected
  hi <- out$upperEndpointMatrix > expected
  return(all(low, hi))
  }
}

defaultFit <- sim_control()$ell_list$ALL$pars$tm

test_res <- stu_year %>% group_by(sid) %>% 
  summarize(fit_ok = test_fit(ell, expected = defaultFit))

table(test_res$fit_ok)
```


Let's look at co-occurrence of status over time. 

```{r CrossTabs}
# Look at by year patterns of relationships by student year
table(FRL = stu_year$frpl, GIFTED = stu_year$gifted)
table(FRL = stu_year$frpl, IEP = stu_year$iep)
table(GIFTED = stu_year$gifted, IEP = stu_year$iep)

```

Let's check polychoric correlations:

```{r}
gamma_GK(stu_year$gifted, stu_year$iep)
gamma_GK(stu_year$frpl, stu_year$iep)
gamma_GK(stu_year$frpl, stu_year$ell)
```


Finally, let's see who winds up "ever" in each category

```{r collapseEver}

test_df <- stu_year %>% group_by(sid) %>% 
  summarize(iep_ever = if_else(any(iep == 1), "Yes", "No"), 
            ell_ever = if_else(any(ell == 1), "Yes", "No"), 
            frpl_ever = if_else(any(frpl == 1), "Yes", "No"), 
            gifted_ever = if_else(any(gifted == 1), "Yes", "No"))

table(IEP_EVER = test_df$iep_ever)
table(ELL_EVER = test_df$ell_ever)
table(FRPL_EVER = test_df$frpl_ever)
table(GIFTED_EVER = test_df$gifted_ever)

```


## Assigning Schools and Outcomes

Students move through grades, schools, and outcomes. 

```{r, include=FALSE, eval=FALSE}
library(lme4)
g12_cohort <- out$stu_year[out$stu_year$grade == "12", ]
g12_cohort <- na.omit(g12_cohort)
g12_cohort <- left_join(g12_cohort, out$demog_master[, 1:4], by = "sid")
g12_cohort$male <- ifelse(g12_cohort$Sex == "Male", 1, 0)
g12_cohort$gpa <- gen_gpa(data = g12_cohort, control = sim_control(nschls = 3))


# Outcome assignment, outcomes are assigned in order
## cum_gpa_final
## sat_act
## hs_diploma
## dropout
## transfer
## disappear
## still_enroll
## ps_enroll

### GPA model
# 0.1839742 theta



#TODO, add code to validate the gpa_sim_parameters list prior to execution

gpa_sim <- gen_outcome_model(fixed = ~ 1 + math_ss + gifted + iep + frpl + ell + male,
                             random_var = 0.02173,
                             cov_param = list(dist_fun = c("rnorm", rep("rbinom", 5)), 
                                              var_type = rep("lvl1", 6), 
                                              opts = list(list(mean = 0, sd = 1), 
                                                          list(size = 1, prob =0.1), 
                                                          list(size = 1, prob = 0.2), 
                                                          list(size = 1, prob = 0.45), 
                                                          list(size = 1, prob = 0.1), 
                                                          list(size = 1, prob = 0.47))),
                             cor_vars = c(0.453, -0.276, -0.309, -0.046, -0.033, 
                                          -0.135, -0.210, -0.030, -0.029, 
                                          0.143, -0.003, 0.127, 
                                          0.060, 0.007, 0.001),
                             fixed_param = c(0.3799, 0.417892, 0.168458, 0.042588580, 
                                             -0.289399599, -0.007401886, -0.374127),
                             ngrps = 30, unbalanceRange = c(100, 1500), type = "linear")

gpa_mod <- lmer(sim_data ~ 1 + gifted + iep + frpl + ell + male + 
                  (1|clustID), data = gpa_sim)


# g12_cohort$gpa <- predict(gpa_mod, newdata = g12_cohort)
zed <- simulate(gpa_mod, nsim = 500, newdata = g12_cohort)
g12_cohort$gpa <- apply(zed, 1, function(x) sample(x, 1))

#mean 2.6266
# sd  0.85406
# zzz <- unscale(zzz, mean = 2.6266, sd = 0.85406)
# table(round(zzz, 1))

## Graduation model


grad_sim <- gen_outcome_model(fixed = ~ 1 + math_ss + gpa + gifted + iep + frpl + ell + male,
                          random_var = 0.07948,
              cov_param = list(dist_fun = c("rnorm", "rnorm", rep("rbinom", 5)), 
                                           var_type = rep("lvl1", 7), 
                               opts = list(list(mean = 0, sd = 1), 
                                           list(mean = 0, sd = 1), 
                                           list(size = 1, prob =0.1), 
                                           list(size = 1, prob = 0.2), 
                                           list(size = 1, prob = 0.45), 
                                           list(size = 1, prob = 0.1), 
                                           list(size = 1, prob = 0.47))),
                          cor_vars = c(0.5136, 0.453, -0.276, -0.309, -0.046, -0.033,
                                       0.2890, -0.1404, -0.2674, -0.0352, -0.1992,
                                       -0.1354, -0.2096, -0.0305, -0.0290,
                                       0.1433, -0.0031, 0.1269,
                                       0.0601, 0.0066, 
                                       0.0009),
                  fixed_param = c(1.7816, 0.10764, 1.05872, -0.07352, -0.07959, -0.331647, 
                                  -0.22318254, 0.0590),
                        ngrps = 30, unbalanceRange = c(100, 1500))
library(lme4)
hs_dipl_mod <- glmer(sim_data ~ gpa + gifted + iep + frpl + ell + male + (1|clustID), 
                     data = grad_sim, family = "binomial")

g12_cohort$grad_prob <- predict(hs_dipl_mod, newdata = g12_cohort, type = "response")


zed <- simulate(hs_dipl_mod, nsim = 500, newdata = g12_cohort, 
                family = "binomial")
g12_cohort$grad_prob <- apply(zed, 1, mean)
g12_cohort$grad <- sapply(g12_cohort$grad_prob, function(x) rbinom(1, 1, x))

# For non-grads sample from the options proportionately
# For grads, model ps_enrollment


# Assignment techniques -- purely ignorant weighting technique
# Non-ignorant, weighted technique
# Model based technique



library(lme4)
# tmp <- head(stu_year$age)
# school_transitions(nschls = 12L)




# Simulation is solid

# Rename to match naming scheme
names(out_sim)[1:7] <- c("intercept", "math_ss","gifted", "iep", "frpl", "ell", "male")

# # Test that model recaptures parameters sent to gen_outcome_model
# summary(glmer(sim_data ~ math_ss + gifted + iep + frpl + ell + male + (1|clustID), 
#               data = out_sim, family = "binomial"))

# Create schools
out_schls <- out_sim %>% group_by(clustID) %>%
  summarize(count = n(), 
            gifted = mean(gifted), 
            ell = mean(ell), 
            frpl = mean(frpl), 
            iep = mean(iep), 
            male = mean(male), 
            dv = randEff[1]) %>% as.data.frame()

plotdf <- out_schls %>% 
  gather(key = "iv", value = "per", 3:7)

library(ggplot2)

ggplot(plotdf, aes(y = dv, x = per)) + 
  geom_point() + facet_wrap(~iv, scale = "free") + geom_smooth(method = "lm")

## Create a data frame of schools with different quality parameters that can be attached 
## to any simulation model


# Model relationship between percentages and random effect
school_assign <- lm(dv ~ ell + frpl + iep + male, data = out_schls)

stu_df <- left_join(stu_year, demog_master[, c("sid", "Sex")])
stu_df$male <- ifelse(stu_df$Sex == "Male", 1, 0)

eligible_assign <- stu_df[stu_df$grade %in% c("9", "10", "11", "12"), 
                          c("sid","ell", "frpl", "iep", "male")]
eligible_assign[, -1] <- apply(eligible_assign[, -1], 2, function(x) as.numeric(as.character(x)))

rescale_school <- function(data, target, vars){
  for(var in vars){
    data[, var] <- sapply(data[, var], function(x) {
      ifelse(x == 1, runif(1, min(target[, var]), quantile(target[, var], 0.1)[[1]]), 
             runif(1, quantile(target[, var], 0.8)[[1]], max(target[, var])))
      })
  }
  return(data)
}

eligible_assign <- rescale_school(eligible_assign, out_schls, 
                                  vars = c("ell", "frpl", "iep", "male"))

assign_probs <- better_sim.lm(school_assign, nsim = 100, newdata = eligible_assign[, -1])
eligible_assign$y <- apply(assign_probs, 1, function(x) sample(x, 1))

match_schools <- function(prob, schlList){
  zzz <- sapply(prob, function(x) {
    schlList$clustID[which(abs(schlList$dv - x) == min(abs(schlList$dv - x)))]
  }
    )
  return(zzz)
}

eligible_assign$schid <- match_schools(eligible_assign$y, 
                                       schlList = out_schls)


outcome_mod <- lmer(math_ss ~ iep + frpl + ell + male + (1|clustID), 
              data = out_sim)

eligible_assign$clustID <- eligible_assign$schid

y <- predict(outcome_mod, newdata = eligible_assign)


ctrl <- sim_control()
schools <- gen_schools(n = 30, mean = ctrl$school_means, 
                       sigma = ctrl$school_cov_mat, names = ctrl$school_names)

```



## Package Dependencies

- `dplyr`
- `lubridate`
- [wakefield](https://www.github.com/trinker/wakefield)


## OpenSDP

`OpenSDP.data` is part of the OpenSDP project. 
