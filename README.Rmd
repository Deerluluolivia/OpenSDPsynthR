---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "tools/figs/README-",
  message = FALSE,
  warning = FALSE
)
```

# OpenSDP Data

A project to generate realistic synthetic unit-level longitudinal education data. 

## Design Goals

1. Generate synthetic education data that is realistic for use by analysts across the education sector. 
 Realistic means messy, and reflective of the general pattern of relationships found in the U.S. education 
 sector. 
2. Synthetic data should be able to be generated on-demand and responsive to inputs from the user. These 
 inputs should allow the user to configure the process to produce data that resembles the patterns of data 
 in their agency. 
3. The package should be modular and extendable allowing new data topics to be generated as needed so synthetic 
 data coverage can grow. 

# Get Started

To use `OpenSDP.data`, follow the instructions below:

## Install Package

```{r eval=FALSE}
devtools::install_github("strategicdataproject/OpenSDP.data")
```

## Make some data

Using the `wakefield` package we can generate a simple set of demographic data. 

```{r, message=FALSE}
library(OpenSDP.data)
library(magrittr)
library(wakefield)
library(lubridate)
set.seed(612)

demog_master <- r_data_frame(n = 500, 
                             id(random = TRUE), 
                             sex, 
                             # dob, set range of years available for birth
                             dob(start = Sys.Date() - 365 * 25, 
                                 k = 365 * 8, by = "1 days"), 
                             race(x = c("White", "Hispanic or Latino Ethnicity", 
                                        "Black or African American", 
                                        "Asian", "American Indian or Alaska Native", 
                                        "Native Hawaiian or Other Pacific Islander", 
                                        "Demographic Race Two or More Races"), 
                                  prob = c(0.637, 0.163, 0.122, 0.047, .007, .0015, .021)))

head(demog_master)
```

Next, let's break the "Race" variable into a series of indicator variables.

```{r}
demog_master %<>% make_inds("Race")
demog_master %<>% mutate_at(5:11, 
                        funs(recode(., `0` = "No", `1` = "Yes")))
head(demog_master[, 4:9])
```

Now, let's generate some variables conditional on `race`. To do this we build a 
list that defines the distribution of this new variable for each category of 
the factor level. 

```{r}
# List of conditional probabilties
ses_list <- list("White" = list(f = rnorm, 
                                pars = list(mean = 0.3, sd = 1.1)), 
                 "Hispanic or Latino Ethnicity" = list(f = rnorm, 
                                pars = list(mean = -0.1, sd = 0.9)),
                 "Black or African American" = list(f = rnorm, 
                                pars = list(mean = -0.2, sd = 1.2)), 
                    "Asian" = list(f = rnorm, 
                                pars = list(mean = 0.23, sd = 1.2)), 
                 "Demographic Race Two or More Races" = list(f = rnorm, 
                                pars = list(mean = 0.0, sd = 1)), 
                 "American Indian or Alaska Native" = list(f = rnorm, 
                                pars = list(mean = -0.2, sd = 1)), 
                    "Other" = list(f = rnorm, 
                                pars = list(mean = 0, sd = 1)),
                 "Native Hawaiian or Other Pacific Islander" = list(f = rnorm, 
                                pars = list(mean = 0, sd = 1))
                    )

ses_list_b <- list("White" = list(f = rbinom, 
                                pars = list(size = 1, prob = 0.4)), 
                 "Hispanic or Latino Ethnicity" = list(f = rbinom, 
                              pars = list(size = 1, prob = 0.6)),
                 "Black or African American" = list(f = rbinom, 
                              pars = list(size = 1, prob = 0.65)), 
                 "Asian" = list(f = rbinom, 
                                pars = list(size = 1, prob = 0.375)), 
                 "Demographic Race Two or More Races" = list(f = rbinom, 
                                pars = list(size = 1, prob = 0.4)), 
                 "American Indian or Alaska Native" = list(f = rbinom, 
                              pars = list(size = 1, prob = 0.4)), 
                 "Other" = list(f = rbinom, 
                                pars = list(size = 1, prob = 0.4)),
                 "Native Hawaiian or Other Pacific Islander" = list(f = rbinom, 
                                  pars = list(size = 1, prob = 0.4))
)

# Note that cond_prob returns the whole data object
demog_master <- as.data.frame(demog_master)
demog_master <- cond_prob(demog_master, factor = "Race", 
                 newvar = "ses", prob_list = ses_list_b)

head(demog_master)
```

Now we have basic individual demographics, let's add annual attributes. 

```{r}
## Generate student-year data
minyear <- 1997
maxyear <- 2016
stu_year <- vector(mode = "list", nrow(demog_master))

# Make a list of dataframes, one for each student, for each year
for(i in 1:nrow(demog_master)){
  tmp <- expand_grid_df(demog_master[i, c(1, 3)], 
                        data.frame(year = 1:12))
  
  tmp$year <- lubridate::year(tmp$DOB + (tmp$year + 4) * 365)
  tmp$year - lubridate::year(tmp$DOB)
  stu_year[[i]] <- tmp; rm(tmp)
}

stu_year <- bind_rows(stu_year) %>% as.data.frame()
stu_year$age <- age_calc(dob = stu_year$DOB, 
                         enddate = as.Date(paste0(stu_year$year, "-09-21")),
                         units = "years", precise = TRUE)

head(stu_year)
```

ELL is a good example. A student's initial ELL status determines future ELL 
status to a high degree. To generate a student's ELL status over time, first 
the initial ELL status of a student needs to be set. Below, a dataframe of 
the first observation for each student in the dataset is created, this contains the 
`ID`, `year`, `age` in years, and `Race` of the student. 

```{r ellInit}
# Create ELL
### Initial
## Identify first enrollment period for a student
## Look up probability based on age/race of being ELL
## Assign student to ELL status or not in first year

stu_first <- stu_year %>% group_by(ID) %>% 
  mutate(flag = if_else(age == min(age), 1, 0)) %>% 
  filter(flag == 1) %>% select(-flag) %>% as.data.frame() %>% 
  select(ID, year, age)
stu_first <- inner_join(stu_first, demog_master[, c("ID", "Race")])
stu_first$age <- round(stu_first$age, 0)
head(stu_first)
```

To assign students to inital ELL status, we need three things: 

1. A function that generates a random status ("ELL", "Not ELL")
2. Parameters that define the probability of being in those two statuses
3. A baseline of observed probabilities defined by those baselines

For ELL status, age and race are strong determinants of initial ELL status. Some 
racial groups are much more likely to be ELL and younger students are more likely 
to be ELL than older students. 

The `OpenSDP.data` package bakes in some baseline values using `baseline` objects. 
A `baseline` object is a simple list with three elements:

1. `keys` - the variable names that are required to match probabilities to cases, 
(e.g. age, race, etc.)
2. `fun` - the function used to generate the student status
3. `data` - the data that sets the parameters of the function

Let's look at the `baseline` for ELL, which can be accessed using the `get_baseline` 
function.

```{r}
bl_data <- get_baseline("ell")
bl_data$keys
```

The keys are `race` and `age` -- to use this baseline we need data that includes 
the student `age` and `race`. 

The function that will be used is `rbinom` and it will be passed one parameter, 
`x`. 

```{r}
bl_data$fun
```

The `bl_data$data` object tells us what the value of `x` will be:

```{r}
head(bl_data$data)
```

For each combination of `age` and `race`, `rbinom` will be assigned a different 
probability, reflecting the empirical observed probability of being an ELL 
given the age and race provided. 

Before we can use this baseline data, however, we need to ensure that the values 
`age` and `race` in our data match those in the `baseline`. We can check that 
this is not the case by comparing:

```{r}
unique(bl_data$data$race)
levels(stu_first$Race)
```

Our `stu_first` object is mapped to the CEDS specification. To convert it from 
CEDS to a more analyst friendly scheme, the `OpenSDP.data` package provides 
the `map_CEDS()` function. 

```{r mapCEDS}
# map_CEDS assigns a new vector, so put it in a new object
stu_first$race <- map_CEDS(stu_first$Race)
table(stu_first$race, stu_first$Race)[, 1:4]
```

With our data matching, we can now use the `assign_baseline()` function. 

```{r}
# Assign baseline creates a new vector, so assign it
stu_first$ell_first <- assign_baseline(baseline = "ell", data = stu_first)
# Recode it
stu_first$ell_first <- ifelse(stu_first$ell_first == 1, "Yes", "No")
head(stu_first)
```

Using the initial ELL status of students it is now possible to simulate the 
transition from ELL to non-ELL student. 

To simulate this process, we can use a Markov chain defined by a transition 
matrix: [https://en.wikipedia.org/wiki/Examples_of_Markov_chains](https://en.wikipedia.org/wiki/Examples_of_Markov_chains)

A transition matrix simply tabulates the number of times a vector transitions 
from one value to another. Given a student whose ELL status is defined as 0 = not 
ELL and 1 = ELL, with annual statuses given by:

```
Student A:
1 1 1 1 1 0 1 0 0 0
```

The transition matrix for this student is then: 

from/to | 0   |   1 |
------- | --- | ----| 
0       | 2    | 1  |
1       | 2    | 4  |

To construct a proper Markov transition matrix, this matrix needs to be converted 
to probabilities, that sum to 1 by rows.

from/to | 0    |   1   |
------- | ---- | ----- | 
0       | 0.66 |  0.33 |
1       | 0.33 |  0.66 |

This can be read as: 

- For a student with ELL status 0, the probability of staying status 0 is 0.66, 
and the probability of switching to status 1 is 0.33
- For a student with ELL status 1, the probability of switching to status 0 is 
0.33, and the probability of staying status 1 is 0.66

Then, using this transition matrix, we can generate a sequence of enrollment 
patterns that fit this process. This approach has two advantages: 

- It generates believable transitions without requiring complex by-year conditional 
probabilities
- It can be adapted to reflect the empirical transition matrix derived from a 
baseline of data

Let's look at an example. First, we combine the first observation for each student 
with the annual data. 

```{r prepData}
stu_year <- left_join(stu_year, stu_first[, c(1, 6)])
head(stu_year)
```

Now we define the transition matrix. Conveniently, we can input the observed 
pattern and then normalize it to a transition matrix by dividing it by the 
`rowSums()`. 

```{r defineTM}
# Define the transition matrix
statesNames <- c("No", "Yes")
tm <- matrix(c(800, 40, 120, 300), nrow = 2, byrow = TRUE,
             dimnames = list(statesNames, statesNames))
tm <- tm / rowSums(tm)
tm
```

Now, for each student we need to apply the transition matrix. Using the `OpenSDP.data` 
function `make_markov_series()`, this is simple. 

```{r}
make_markov_series(10, tm = tm)
```

And applying it to each student: 

```{r applyTMtoELL}
stu_year <- stu_year %>% 
  group_by(ID) %>% 
  arrange(ID, year) %>%
  mutate(ell = make_markov_series(n() - 1, 
          tm = tm, #define transition matrix
          t0 = ell_first[1], # specify that the matrix should start with first obs
          include.t0 = TRUE) # include the first observation in the sequence
         )

table(initialELL =stu_year$ell_first, byyear = stu_year$ell)
```

### Diagnostics

How do we know it worked? We can look at the patterns of ELL enrollment that 
are observed and see what patterns are the most common. To do this, let's compute 
the frequency of transition states observed per student. 

```{r ellDiagnostic}
library(ggplot2)
library(tidyr)
plotdf <- stu_year %>% arrange(ID, year) %>% group_by(ID) %>% 
  do(tidy_sequence(.$ell, states = c("Yes", "No")))

plotdf$total <- rowSums(plotdf[, -1])
plotdf <- plotdf %>% gather(-ID, key = "Transition", value = "Count")

plotdf <- plotdf %>% group_by(ID) %>% 
  mutate(total = sum(Count)) %>% 
  mutate(per = Count / total) %>% filter(Transition != "total")  %>% 
  separate(Transition, into = c("From", "To"), sep = "-")

ggplot(plotdf, aes(Count)) + geom_histogram() + 
  scale_x_continuous(breaks = c(0:11)) + 
  facet_grid(From~To, labeller = label_both, switch = "y") + 
  theme_bw() + 
  labs(title = "Frequency of Transition States by Student", 
       y = "Count", x = "Times per Student State Observed")

```


```{r eval = FALSE, include=FALSE}

ggplot(plotdf[plotdf$Transition!="total", ], 
       aes(x = Transition, y = Count)) + 
  geom_bar(stat = 'identity')


plotdf <- 


plotdf %>% group_by(From, To) %>% 
  summarise(Count = sum(Count)) %>% 
ggplot(aes(x = From, y = To, fill = Count)) + 
  geom_tile() + geom_text(aes(label = Count))


plotdf %>% group_by(From, To) %>% 
  summarise(Count = sum(Count)) %>% 
  ungroup %>% 
  mutate(total = sum(Count)) %>%
  mutate(per = Count/total) %>%
ggplot(aes(x = From, y = To, fill = per)) + 
  geom_tile() + geom_text(aes(label = round(per, digits = 2)))


# Conditional markovchains
tm_f <- matrix(c(900, 200, 300, 2000), nrow = 2, byrow=TRUE, 
               dimnames = list(statesNames, statesNames))

make_markov_series(20, tm = tm_f/rowSums(tm_f))

tm_list <- replicate(8, matrix(c(sample(750:900, 1),
                    sample(400:500, 1),
                    sample(125:175, 1),
                    sample(1500:2200, 1)),
                    2, 2, dimnames = list(c("Yes", "No"), 
                    c("Yes", "No"))), simplify = FALSE) %>% lapply(function(x) x / rowSums(x))


ses_list_MC <- list("White" = list(f = make_markov_series, 
                                pars = list(tm = tm_list[[1]])), 
                 "Hispanic or Latino Ethnicity" = list(f = make_markov_series, 
                                pars = list(tm = tm_list[[2]])),
                 "Black or African American" = list(f = make_markov_series, 
                                pars = list(tm = tm_list[[3]])),
                 "Asian" = list(f = make_markov_series, 
                                pars = list(tm = tm_list[[4]])), 
                 "Demographic Race Two or More Races" = list(f = make_markov_series, 
                                pars = list(tm = tm_list[[5]])), 
                 "American Indian or Alaska Native" = list(f = make_markov_series, 
                                pars = list(tm = tm_list[[6]])), 
                 "Other" = list(f = make_markov_series, 
                                pars = list(tm = tm_list[[7]])),
                 "Native Hawaiian or Other Pacific Islander" = list(f = make_markov_series, 
                                pars = list(tm = tm_list[[8]])))

# grade_level
gradeNames <- c("1", "0", "-1")
tm_grade <- matrix(c(900, 50, 10, 900, 20, 10, 900, 20, 10), nrow = 3, byrow=TRUE, 
               dimnames = list(gradeNames, gradeNames))
testMC <- as(tm_grade/rowSums(tm_grade), "markovchain")

tm_grade_f <- tm_grade/rowSums(tm_grade)
tm_grade_m <- tm_grade
tm_grade_m[, 2] <- tm_grade_m[, 2] + 30
tm_grade_m[, 3] <- tm_grade_m[, 3] + 5
tm_grade_m <- tm_grade_m/rowSums(tm_grade_m)

retention_list <- list("Male" = list(f = make_markov_series, 
                                     pars = list(tm = tm_grade_m)),
                       "Female" = list(f = make_markov_series, 
                                       pars = list(tm_grade_f)))

testDF <- left_join(stu_year[, c(1:4)], demog_master[, c(1, 2, 4)])

testDF <- as.data.frame(testDF)
testDF <- cond_prob(testDF, factor = "Race", 
                 newvar = "frpl", prob_list = ses_list_MC)
testDF <- cond_prob(testDF, factor = "Sex", 
                 newvar = "grade_adv", prob_list = retention_list)

results <- testDF %>% group_by(Sex, ID) %>% 
  do(.out = createSequenceMatrix(.$grade_adv, possibleStates = c("-1", "0", "1"))) %>% 
  ungroup %>%
  nest(-Sex) %>%
  mutate(summed = map(data, ~ reduce(.$.out, `+`)))

lst <- results$summed
names(lst) <- results$Sex
lst 

# 
zed <- results %>%
  select(-data) %>%
  spread(Sex, summed) %>% 
  at_depth(zed, 2, .f = function (x) x / rowSums(x))



### 
zed %>% map("m_sum")
zed %>% detect("m_sum")

# sum matrices in list column by grouping variable
library(tidyverse)

m <- matrix(1:4, ncol = 2)
d <- data_frame(g = c('a', 'a', 'b', 'b', 'b', 'c'),
                m = rep(list(m), 6))



group_by(d, g) %>%
  summarise(m_sum = m_sum(m)) %>%
  select(m_sum) %>%
  unlist(recursive = FALSE)



testDF %>% group_by(Sex) %>%
  split(.$ID) %>% select(grade_adv) %>% 
  map(~ createSequenceMatrix(possibleStates = c("-1", "0", "1"))) %>% 
  reduce(`+`)


testDF %>% split(.$ID) %>% 
  bind_rows() %>% 
  group_by(Sex) %>%
  summarise_each(sum)

zed <- testDF %>%
  group_by(Sex, ID) %>% 
  group_by(ID) %>%
  by_slice(~ createSequenceMatrix(., possibleStates = c("-1", "0", "1")), .labels =TRUE) %>% 
  group_by(Sex) %>% 
  reduce(`+`)
  
 %>% 
  



testDF %>% 
  split(.$ID) %>% 
  by_slice(~ createSequenceMatrix(.x$grade_adv, possibleStates = c("-1", "0", "1"))) %>% 
  reduce(`+`)

testDF %>%
  slice_rows("ID") %>%
  nest() %>% 
  mutate(.out = map(.$data, partial(lm, mpg ~ disp)))


# Build diagnostics to ensure things are different by group

```


```{r diagnostics, eval=FALSE, include=FALSE}
emp_tm <- out %>% group_by(ell_first) %>% split(.$ID) %>% 
  map(~ createSequenceMatrix(.x$ell, possibleStates = c("Yes", "No"))) %>% 
  reduce(`+`)

emp_tm <- out %>% split(.$ID) %>% 
  map(~ createSequenceMatrix(.x$ell, possibleStates = c("Yes", "No"))) %>% 
  reduce(`+`)

library(tidyr); library(viridis)
stu_year %>% split(.$ID) %>% 
  map(~ createSequenceMatrix(.x$grade_adv, possibleStates = c("-1", "0", "1"))) %>% 
  reduce(`+`) %>% tidy() %>% 
  gather(2:ncol(.), key = "to", value = "n") %>% 
  rename(from = .rownames) %>% 
  ggplot(aes(x = from, y = to, fill = n)) + geom_tile() + 
  scale_fill_viridis(direction = -1) + geom_text(aes(label = n))



ggplot(stu_year[stu_year$ID %in% unique(stu_year$ID)[1:50],], 
       aes(x = year, y = as.numeric(factor(frpl)), 
       group = ID)) + 
  geom_step(stat = "identity", alpha = I(0.1)) + 
  scale_y_discrete("FRPL", breaks = c(1, 2), labels = c("No", "Yes")) + 
  scale_x_continuous(breaks = c(1998:2017))


ggplot(out, aes(x = year, y = as.numeric(factor(ell)))) + 
  geom_step(stat = "identity") + 
  theme_bw() + 
  scale_y_discrete(name = "State", breaks = c(1, 2), 
                   labels = c("No", "Yes"))

```


## Package Dependencies

- `dplyr`
- `lubridate`
- [wakefield](https://www.github.com/trinker/wakefield)


## OpenSDP

`OpenSDP.data` is part of the OpenSDP project. 
