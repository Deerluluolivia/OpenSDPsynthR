#' @importFrom stats rbinom runif
#' @importFrom utils data head tail
#' @importFrom methods new

.onAttach = function(...) {
  if (!interactive()) return()
  msg = "Welcome to OpenSDP." # nocov
  packageStartupMessage(paste(strwrap(msg), collapse = "\n")) # nocov
}


#' Sum matrix elements in a list
#'
#' @param l a list
#'
#' @return a list of summed matrix elements
#' @importFrom magrittr %>%
m_sum <- function(l) {
  reduce(l, `+`) %>% lisst()
}

#' Tidy a two-state markov sequence for output
#'
#' @param seq a vector of sequence elements, with only two states
#' @param states a vector of length two naming both possible states
#'
#' @return a data.frame
#' @importFrom markovchain createSequenceMatrix
#' @export
#' @examples
#' tidy_sequence(seq = c("Yes", "No", "No", "No", "Yes", "Yes"),
#'              states = c("Yes", "No"))
tidy_sequence <- function(seq, states){
  stopifnot(length(states) == 2)
  tmp <- markovchain::createSequenceMatrix(seq, possibleStates = states)
  newNames <- outer(dimnames(tmp)[[1]], dimnames(tmp)[[2]], paste, sep = "-")
  dim(newNames) <- NULL
  dim(tmp) <- c(1, 4)
  tmp <- as.data.frame(tmp)
  colnames(tmp) <- newNames
  return(tmp)
}

#' Compute conditional Markov sequences in a pipeline
#'
#' @param groupname variable that identifies the list element to use
#' @param n number of elements to generate, usually defined by \code{\link{n()}} in dplyr
#' @param lst probability list that contains function and function parameters
#'
#' @return A sequence generated by functions in the probability list
#' @export
markov_cond_list <- function(groupname, n, lst){
  # TODO: add checks to lst
  do.call(lst[[groupname]]$f,
          c(list(n = n), lst[[groupname]]$pars),
          quote = FALSE)
}

